package com.nfcalarmclock;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.RectF;
import android.graphics.Paint;
import android.graphics.PorterDuff;
import android.support.v4.content.ContextCompat;
import android.support.v7.widget.helper.ItemTouchUIUtil;
import android.support.v7.widget.helper.ItemTouchHelper;
import android.support.v7.widget.RecyclerView;
import android.support.v7.widget.RecyclerView.ViewHolder;
import android.view.MotionEvent;
import android.view.View;

enum ButtonState
{
    GONE,
    LEFT_VISIBLE,
    RIGHT_VISIBLE
}

public class NacCardTouchHelperCallback
	extends ItemTouchHelper.Callback
	implements View.OnTouchListener
{

    private NacCardTouchHelperAdapter mAdapter = null;
	private Canvas mCanvas = null;
	private RecyclerView mRecyclerView = null;
	private ViewHolder mViewHolder = null;
	private float mDx = 0;
	private boolean mActive = false;
	private ButtonState mState = ButtonState.GONE;
	private RectF mRect = null;
	private Paint mPaint = null;
	private static final float mWidth = 100;
	private Bitmap mIconCopy = null;
	private Bitmap mIconDelete = null;

	/**
	 * @param  adapter  The object that overrides the event methods.
	 */
    public NacCardTouchHelperCallback(NacCardTouchHelperAdapter adapter)
	{
        mAdapter = adapter;
    }

	/**
	 * @brief Set the RectF object.
	 *
	 * @param  holder  The view holder.
	 * @param  loffset  The dx amount on the left.
	 * @param  roffset  The dx amount on the right.
	 */
	private void setRectF(ViewHolder holder, float loffset, float roffset)
	{
		View v = ((NacCard)holder).mCard;
		int pos = holder.getAdapterPosition();
		float height = (float) v.getHeight();
		//float width = height / 3;
		float top = (float) pos * height;
		float bottom = (float) top + height;
		float right = (roffset != 0) ? roffset : (float) v.getRight();
		float left = (loffset != 0) ? right+loffset : (float) v.getLeft();

		mRect = new RectF(left, top, right, bottom);
	}

	/**
	 * @brief Draw the frame of the drawn button.
	 * 
	 * @param  c  The canvas.
	 * @param  p  The paint.
	 * @param  holder  The view holder.
	 * @param  color  The color to draw the frame.
	 */
	private void drawButtonFrame(Canvas c, Paint p, ViewHolder holder, int id)
	{
		Context context = ((NacCard)holder).mContext;
		int color = ContextCompat.getColor(context, id);

		NacUtility.printf("Canvas : %d || Hold : %d || Rect : %d",
			c.hashCode(), holder.hashCode(), mRect.hashCode());

		p.setColor(color);
		c.drawRect(mRect, p);
	}

	/**
	 * @brief Draw the icon of the drawn button.
	 * 
	 * @param  c  The canvas.
	 * @param  p  The paint.
	 * @param  holder  The view holder.
	 * @param  color  The color to draw the frame.
	 */
	private void drawButtonIcon(Canvas c, Paint p, ViewHolder holder, int id)
	{
		Resources r = ((NacCard)holder).mContext.getResources();
		Bitmap icon = null;
		RectF rect = null;

		//if ((id == R.mipmap.baseline_file_copy_white_48) && (mIconCopy == null))
		if (mDx > 0)
		{
			if (mIconCopy == null)
			{
				NacUtility.printf("Creating IconCopy.");
				mIconCopy = BitmapFactory.decodeResource(r, id);
			}

			icon = mIconCopy;
		}

		//if ((id == R.mipmap.baseline_delete_white_32dp) && (mIconDelete == null))
		if (mDx < 0)
		{
			if (mIconDelete == null)
			{
				NacUtility.printf("Creating IconDelete.");
				mIconDelete = BitmapFactory.decodeResource(r, id);
			}

			icon = mIconDelete;
		}

		if (icon == null)
		{
			NacUtility.printf("Icon is NULL :(");
			return;
		}

		float left = mRect.left;
		float top = mRect.top;
		float right = mRect.right;
		float bottom = mRect.bottom;
		float width = (float) icon.getWidth();
		float height = (float) icon.getHeight();

		if (mDx > 0)
		{
			rect = new RectF(left+width/2, top+height/2,
				left+width, bottom-height/2);
		}
		else if (mDx < 0)
		{
			rect = new RectF(right-width, top+height/2,
				right-width/2, bottom-height/2);
		}

		if (rect == null)
		{
			NacUtility.printf("Rect is NULL :(");
			return;
		}

		NacUtility.printf("Left : %f || Top : %f || Right : %f || Bottom : %f || Width : %f || Height : %f",
			left, top, right, bottom, width, height);
		c.drawBitmap(icon, null, rect, p);
	}

	/**
	 * @brief Draw the text in the drawn buttons.
	 *
	 * @param  c  The canvas.
	 * @param  p  The paint.
	 * @param  text The text to display.
	 */
    private void drawButtonText(Canvas c, Paint p, String text)
	{
		if (mRect == null)
		{
			NacUtility.print("Rect is NULLLLLLL");
			return;
		}

		RectF rect = mRect;
        float size = 50;
        float width = p.measureText(text);
		float x = rect.centerX() - (width/2);
		float y = rect.centerY() + (size/2);

        p.setColor(Color.WHITE);
        p.setAntiAlias(true);
        p.setTextSize(size);
        c.drawText(text, x, y, p);
	}

	/**
	 * @brief Draw the button that is displayed to the left of the card.
	 *
	 * @param  c  The canvas.
	 * @param  holder  The view holder.
	 * @param  dx  The dx amount.
	 */
	private void drawLeftButton(Canvas c, ViewHolder holder, float dx)
	{
		//left, top dx, bottom
		Paint p = new Paint();
		//if ((id == ) && (mIconCopy == null))
		//if ((id == ) && (mIconDelete == null))

		setRectF(holder, 0, dx);
		drawButtonFrame(c, p, holder, R.color.orange);
		drawButtonIcon(c, p, holder, R.mipmap.baseline_file_copy_white_48);
		//drawButtonText(c, "Copy");
	}

	/**
	 * @brief Draw the button that is displayed to the right of the card.
	 *
	 * @param  c  The canvas.
	 * @param  holder  The view holder.
	 * @param  dx  The dx amount.
	 */
	private void drawRightButton(Canvas c, ViewHolder holder, float dx)
	{
		// right+dx, top, right, bottom
		Paint p = new Paint();

		setRectF(holder, dx, 0);
		drawButtonFrame(c, p, holder, R.color.red);
		drawButtonIcon(c, p, holder, R.mipmap.baseline_delete_white_32dp);
		//drawButtonText(c, "Delete");
	}

	/**
	 * @brief Reset the drawn items to their original state.
	 */
	private void drawReset()
	{
		NacUtility.print("Resetting drawing.");
		mDx = 0;
		mActive = false;
		mState = ButtonState.GONE;
		//mRect = null;
		//mPaint = null;
		//mCanvas = new Canvas();
		//mCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.MULTIPLY);

		super.onChildDraw(mCanvas, mRecyclerView, mViewHolder, 0f, 0f, 1,
			false);
		//super.clearView(mRecyclerView, mViewHolder);
	}

	/**
	 * @brief Calculate the value of dx.
	 * 
	 * @param  dx  The current value of dx.
	 */
	private float calculateDx(float dx)
	{
		float max = (float) mRecyclerView.getWidth() / 2;
		float calculated = dx;

		if ((mDx*dx) < 0)
		{
			setState(dx);
			return dx;
		}

		if (mState == ButtonState.LEFT_VISIBLE)
		{
			NacUtility.printf("mDx = %f || Dx = %f || Active = %b",
				mDx, dx, mActive);

			if (mActive && (mDx > calculated))
			{
				calculated += mWidth;
			}

			calculated = Math.max(calculated, mWidth);
		}
		else if (mState == ButtonState.RIGHT_VISIBLE)
		{
			NacUtility.printf("mDx = %f || Dx = %f || Active = %b",
				mDx, dx, mActive);

			if (mActive && (mDx < calculated))
			{
				calculated -= mWidth;
			}

			calculated = Math.min(calculated, -mWidth);
		}
		else
		{
			NacUtility.printf("Max = %f || mDx = %f || dx = %f", max, mDx, dx);
			if ((mDx == 0) && (dx >= max))
			{
				calculated = 0;
			}
		}

		if (Math.abs(calculated) > max)
		{
			calculated = max;
		}

		return calculated;
	}

	/**
	 * @brief Set the button state.
	 * 
	 * @param  dx  The dx value.
	 */
	private void setState(float dx)
	{
		if (dx <= -mWidth)
		{
			mState = ButtonState.RIGHT_VISIBLE;
		}
		else if (dx >= mWidth)
		{
			mState = ButtonState.LEFT_VISIBLE;
		}
		else
		{
			mState = ButtonState.GONE;
		}
	}

	/**
	 * @return True if view holder was changed and false otherwise.
	 */
	private boolean isViewHolderChanged(ViewHolder holder)
	{
		if ((mViewHolder == null) || (holder == null))
		{
			return false;
		}

		return (holder.getAdapterPosition() != mViewHolder.getAdapterPosition());
	}

	/**
	 * @return True if the view holder was deselected and false otherwise.
	 */
	private boolean isViewHolderDeselected()
	{
		return ((mState != ButtonState.GONE) && !mActive);
	}

	/**
	 * @return True if the view holder was selected and false otherwise.
	 */
	private boolean isViewHolderSelected(MotionEvent event)
	{
		if ((mAdapter == null) || (mRect == null) || (mViewHolder == null))
		{
			return false;
		}

		return mRect.contains(event.getX(), event.getY());
	}

	/**
	 * @brief Set the button state when the card is being swiped.
	 *
	 * @details This will stop the card from being completely swiped away.
	 *
	 * @param  flags  The movement flags.
	 * @param  direction  The direction the card is moving.
	 */
	@Override
	public int convertToAbsoluteDirection(int flags, int direction)
	{
		NacUtility.printf("Converting to absolute direction. mDx = %f || Flags : %d || Direction : %d",
			mDx, flags, direction);

		if (mDx != 0)
		{
			NacUtility.print("NOT calling onDraw method.");

			setState(mDx);
			//if (mDx <= -mWidth)
			//{
			//	mState = ButtonState.RIGHT_VISIBLE;
			//}
			//else if (mDx >= mWidth)
			//{
			//	mState = ButtonState.LEFT_VISIBLE;
			//}
			//else
			//{
			//	mState = ButtonState.GONE;
			//}

			//return 0;
		}

    	return super.convertToAbsoluteDirection(flags, direction);
	}

	/**
	 * @brief Set te movement flags for the card, to allow it to be swiped
	 *        left and right.
	 *
	 * @param  rv  The recycler view.
	 * @param  holder  The view holder.
	 */
    @Override
    public int getMovementFlags(RecyclerView rv, ViewHolder holder)
	{
		NacUtility.printf("Getting movement flags! %b %b" , (rv == null), (holder == null));
        return makeMovementFlags(0,
			ItemTouchHelper.LEFT|ItemTouchHelper.RIGHT);
    }

	@Override
	public float getSwipeThreshold(ViewHolder holder)
	{
		NacUtility.printf("~~~~~~~~~~~~~~~~~~~~~~ Running getSwipeThreshold. threshold = %f", super.getSwipeThreshold(holder));
		return 0.99f;
	}

	@Override
	public float getSwipeEscapeVelocity(float defaultValue)
	{
		NacUtility.printf("~~~~~~~~~~~~~~~~~~~~~~~~ Running getSwipeEscapeVelocity. default = %f", defaultValue);
		return 100*defaultValue;
	}

	@Override
	public float getSwipeVelocityThreshold(float defaultValue)
	{
		NacUtility.printf("~~~~~~~~~~~~~~~~~~~~~~~~~ Running getSwipeVelocityThreshold. default = %f", defaultValue);
		return defaultValue;
	}

	/**
	 * @brief Allow the card to be swiped.
	 */
    @Override
    public boolean isItemViewSwipeEnabled()
	{
		boolean b = (mViewHolder == null) ? true : ((NacCard)mViewHolder).isCollapsed();
		NacUtility.printf("CHECKING IF ITEM VIEW SWIPE IS ENABLED. %b", b);
        return b;
    }

	/**
	 * @brief Draw the child.
	 */
	@Override
	public void onChildDraw(Canvas c, RecyclerView rv, ViewHolder holder,
		float dx, float dy, int action, boolean active)
	{
		//NacUtility.printf("Canvas : %d || Hold : %d || Dx : %f || Button State : %s",
		//	c.hashCode(), holder.hashCode(), dx, mState.toString());
		NacUtility.printf("Running onChildDraw. dx = %f || Active = %b", dx, active);

		if (isViewHolderChanged(holder))
		{
			mWhat = 0;
			drawReset();
		}

		mCanvas = c;
		mRecyclerView = rv;
		mViewHolder = holder;
		mActive = active;

		if (action == ItemTouchHelper.ACTION_STATE_SWIPE)
		{
			dx = calculateDx(dx);

			if (dx > 0)
			{
				mWhat = 1;
				drawLeftButton(c, holder, dx);
			}
			else if (dx < 0)
			{
				mWhat = 2;
				drawRightButton(c, holder, dx);
			}
            else
			{
				mWhat = 0;
				rv.setOnTouchListener(this);
            }
        }

		mDx = dx;

		NacUtility.printf("Canvas : %d || Hold : %d || Dx : %f || Button State : %s",
			c.hashCode(), holder.hashCode(), dx, mState.toString());

		super.onChildDraw(c, rv, holder, dx, dy, action, active);
	}

	@Override
	public void clearView(RecyclerView rv, ViewHolder holder)
	{
		NacUtility.printf("Running clearView.");
		super.clearView(rv, holder);
	}

	/**
	 * @brief Disallow movement of cards.
	 *
	 * @param  rv  The recycler view.
	 * @param  holder  The view holder.
	 * @param  target  The target view holder.
	 */
    @Override
    public boolean onMove(RecyclerView rv, ViewHolder holder, ViewHolder target)
	{
        return false;
    }

	/**
	 * @brief Called when the card is being swiped.
	 *
	 * @param  holder  The view holder.
	 * @param  direction  The direction the card is being swiped.
	 */
    @Override
    public void onSwiped(ViewHolder holder, int direction)
	{
		NacUtility.printf("~~~~ Running onSwiped in %d direction.", direction);
    }

	/**
	 * @brief Catch events when the recycler view is touched.
	 *
	 * @param  v  The view.
	 * @param  event  The motion event.
	 */
	@Override
	public boolean onTouch(View v, MotionEvent event)
	{
		// Seems like the act of going into onTouch made the canvas disappear.
		NacUtility.printf("OnTouch with event %d", event.getAction());

		if (event.getAction() == MotionEvent.ACTION_UP)
		{
			NacUtility.print("Motion action up.");
			if (isViewHolderSelected(event))
			{
				NacUtility.print("View holder is selected.");
				if (mState == ButtonState.LEFT_VISIBLE)
				{
					mAdapter.onItemCopy(mViewHolder.getAdapterPosition());
				}
				else if (mState == ButtonState.RIGHT_VISIBLE)
				{
					mAdapter.onItemDelete(mViewHolder.getAdapterPosition());
				}
			}

			if (isViewHolderDeselected())
			{
				NacUtility.print("View holder is deselected.");
				drawReset();
			}
		}

		return false;
	}

	@Override
	public long getAnimationDuration(RecyclerView rv, int type, float dx, float dy)
	{
		NacUtility.print("Get Animation duration!");
		return super.getAnimationDuration(rv, type, dx, dy);
	}

	///@Override
	//public static ItemTouchUIUtil getDefaultUIUtil()
	//{
	//	NacUtility.print("Item touch UI Util!");
	//	return super.getDefaultUIUtil();
	//}

	private int mWhat = 0;
	@Override
	public void onChildDrawOver(Canvas c, RecyclerView rv, ViewHolder holder,
		float dx, float dy, int action, boolean active)
	{
		NacUtility.printf("On Child Draw Over! Mdx = %f || dx = %f || Active = %b",
			mDx, dx, active);
		super.onChildDrawOver(c, rv, holder, mDx, dy, action, active);
		//if (mWhat == 0)
		//{
		//	NacUtility.print("Drawing NOTHING.");
		//	//mCanvas.drawColor(Color.TRANSPARENT, Mode.MULTIPLY);
		//}
		//else if (mWhat == 1)
		//{
		//	NacUtility.print("Drawing the Left sucker.");
		//	drawLeftButton(c, holder, mDx);
		//}
		//else if (mWhat == 2)
		//{
		//	NacUtility.print("Drawing the Right sucker.");
		//	drawRightButton(c, holder, mDx);
		//}
	}

	@Override
	public void onSelectedChanged(ViewHolder holder, int action)
	{
		NacUtility.printf("On Selected Changed!");

		super.onSelectedChanged(holder, action);
	}

}


			//if (active || (mState == ButtonState.GONE))
			//{
			//	if (dx > 0)
			//	{
			//		drawLeftButton(c, holder, dx);
			//	}
			//	else if (dx < 0)
			//	{
			//		drawRightButton(c, holder, dx);
			//	}
			//}

            //if (mState != ButtonState.GONE)
			//{
            //    if (mState == ButtonState.LEFT_VISIBLE)
			//	{
			//		dx = Math.max(dx, mWidth);
			//		drawLeftButton(c, holder, dx);
			//	}
            //    else if (mState == ButtonState.RIGHT_VISIBLE)
			//	{
			//		dx = Math.min(dx, -mWidth);
			//		drawRightButton(c, holder, dx);
			//	}
            //}
            //else
			//{
			//	rv.setOnTouchListener(this);
            //}

			//Paint p = new Paint();
			//Resources r = ((NacCard)holder).mContext.getResources();
			//View v = ((NacCard)holder).mCard;
			//float top = (float) v.getTop();
			//float bottom = (float) v.getBottom();
			//float left = (float) v.getLeft();
			//float right = (float) v.getRight();
			//float height = bottom - top;
			//float width = height / 3;


			//if (dx > 0)
			//{
			//	p.setColor(Color.parseColor("#388E3C"));

			//	RectF background = new RectF(left, top, dx, bottom);

			//	c.drawRect(background, p);

			//	Bitmap icon = BitmapFactory.decodeResource(r,
			//		R.mipmap.baseline_delete_white_32dp);
			//		//R.drawable.ic_mode_edit_white_24dp);
			//	RectF icon_dest = new RectF(left+width, top+width,
			//		left+2*width, bottom-width);

			//	c.drawBitmap(icon, null, icon_dest, p);
			//}
			//else if (dx < 0)
			//{
			//	p.setColor(Color.parseColor("#D32F2F"));

			//	RectF background = new RectF(right+dx, top, right, bottom);

			//	c.drawRect(background, p);

			//	Bitmap icon = BitmapFactory.decodeResource(r,
			//		R.mipmap.baseline_delete_white_32dp);
			//	RectF icon_dest = new RectF(right-2*width, top+width,
			//		right-width, bottom-width);

			//	c.drawBitmap(icon, null, icon_dest, p);
			//}
			//else
			//{
			//}
